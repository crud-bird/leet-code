func isEscapePossible(blocked [][]int, source []int, target []int) bool {
    //只检查sourece到target会存在target被包围的情况
    return walk(blocked, source, target) && walk(blocked, target, source)
}

func walk(blocked [][]int, source []int, target []int) bool {
	if len(blocked) < 2 {
		return true
	}

  //blocked能包围的最大面积，以边界为边的直角三角形
  max := len(blocked)*len(blocked)/2
  
  //转成map提高查找效率
	bMap := make(map[string]bool)
	for _, arr := range blocked {
		bMap[fmt.Sprintf("%d,%d", arr[0], arr[1])] = true
	}

	route := [][]int{{source[0],source[1]}}
    bMap[fmt.Sprintf("%d,%d", source[0], source[1])] = true
	for len(route) > 0 {
		if source[0] == target[0] && source[1] == target[1] {
			return true
		}

        if len(route)> max {
            return true
        }

		bMap[fmt.Sprintf("%d,%d", source[0], source[1])] = true
		//向右
		if source[0]+1 < 1000000 && !bMap[fmt.Sprintf("%d,%d", source[0]+1, source[1])] {
			route = append(route, []int{source[0], source[1]})
			source[0]++
			continue
		}

		//向下
		if source[1]+1 < 1000000 && !bMap[fmt.Sprintf("%d,%d", source[0], source[1]+1)] {
			route = append(route, []int{source[0], source[1]})
			source[1]++
			continue
		}

		//向左
		if source[0]-1 >= 0 && !bMap[fmt.Sprintf("%d,%d", source[0]-1, source[1])] {
			route = append(route, []int{source[0], source[1]})
			source[0]--
			continue
		}

		//向上
		if source[1]-1 >= 0 && !bMap[fmt.Sprintf("%d,%d", source[0], source[1]-1)] {
			route = append(route, []int{source[0], source[1]})
			source[1]--
			continue
		}

        l := len(route)
		source = route[l-1]
		route = route[:l-1]
	}

	return false
}
